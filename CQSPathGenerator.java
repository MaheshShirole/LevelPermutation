package ScenarioGenerator;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

public class CQSPathGenerator extends PathGenerator {
	static int decisionCount=0;
	static Activity tempActivity=null;

	CQSPathGenerator(ActivityGraph graph) {
		super(graph);
		// TODO Auto-generated constructor stub
	}

	@Override
	public String getPath() {
		String path = "";
		path=CQS();
		graph.clearNodes();
		return path;
	}

	@Override
	public String[] getPathSet(int noOfPaths) {
		setStartTime();
		String [] pathSet= new String[noOfPaths];
		for(int i=0;i<noOfPaths;i++){
			pathSet[i]=this.getPath();
		}
		setEndTime();
		return pathSet;
	}
	private String CQS(){
		String resultPath="";
		
		 // First phase : create concurrent queues.
		 Queue main_queue=new LinkedList(); // main queue
		 Queue [] fork_queue=null;
		 Activity temp = graph.getActivity(graph.getRootNode()); //get root node of the tree
		 main_queue.add(temp);// add root node in the queue
		 temp.setVisited(true); // set visited flag true
		 //System.out.println(temp);
		 Activity child=null;
		 Activity n=temp;
		 while((child=graph.getUnvisitedChildNode(n))!=null)
		 {
			 if(child.getType().equals("Action"))
				 main_queue.add(child);
			 if(child.getType().equals("End"))
				 main_queue.add(child);
			 if(child.getType().equals("Decision")){
				 temp=child;
				 //System.out.println("my data "+temp);
				 // add true part to the queue UPTO MERGER NODE
				 while((child=graph.getUnvisitedChildNode(n))!=null && !(child.getType().equals("Merge"))){
					 main_queue.add(child);
					// System.out.println(child);
					 child.setVisited(true);
					 n=child;
				 }
				 main_queue.add(child); //add merge node
				 //System.out.println(child);
				 // add false part to the queue UPTO MERGER NODE
				 n=temp;
				 n.setVisited(false);
				 while((child=graph.getUnvisitedChildNode(n))!=null && !(child.getType().equals("Merge"))){
					 main_queue.add(child);
					// System.out.println(child);
					 child.setVisited(true);
					 n=child;
				 }
				 main_queue.add(child); //add merge node
			 }
			 
			 // fork node create new concurrent queues.
			if(child.getType().equals("Fork")){
				 temp=child;
				 main_queue.add(child); // insert fork node in main queue.
				 int i =child.getId(); // get id of the activity n
				 //System.out.println("my data "+temp+" No of fork out:"+graph.getAdjacencyCount(child));
				 fork_queue =new Queue[graph.getAdjacencyCount(child)];
				 int Threads=graph.getAdjacencyCount(child);
				 for(int j=0;j<Threads;j++){
					 fork_queue[j]= new LinkedList();
					// System.out.println("fork--"+child);
					 n=temp;
					 n.setVisited(false);
					 while((child=graph.getUnvisitedChildNode(n))!=null && !(child.getType().equals("Join"))){
						 fork_queue[j].add(child);
						// System.out.println(child);
						 child.setVisited(true);
						 n=child;
					 }
					 //System.out.println("fork==>"+child+"j="+j+"Threads:"+Threads);
				 }
				 
				 main_queue.add(child); // insert join node in main queue.

			}
			 //System.out.println(child);
			 n=child;
		 }
		// System.out.println(main_queue);
		 //System.out.println(fork_queue[0]);
		 //System.out.println(fork_queue[1]);
		 
		 // Second Phase generate search path
		 //System.out.println("Path Generated by the CQS algorithm");
		 //System.out.println("");
		 while(!main_queue.isEmpty()){
			 //System.out.println("Queue not empty");
			 Activity test=(Activity)main_queue.remove();
			 String type= test.getType();
			 
			 // print action nodes
			 if(type.equals("Action")||type.equals("Start")||type.equals("End"))
				 //System.out.print(test.getName()+"-");
			 	 resultPath+=test.getName()+"-";
			 // print decision node approapriate part of main que on basis of PreCondition
			 if(type.equals("Decision")){
				 if(test.getPreCondition().equals("true")){
					 // print activities up to merge and then skip activities up to merge
					 //System.out.print(test+" : "+test.getPreCondition()); // print decision node
					 //System.out.print(test.getType()+"-"); // print decision node
					 resultPath+=test.getName()+"-";
					 while(!main_queue.isEmpty() && !type.equals("Merge")){
						 test=(Activity)main_queue.remove();
						 type= test.getType();
						 //System.out.print(test.getName()+"-");
						 resultPath+=test.getName()+"-";
					 }
					 // Skip activities in false part
					 while(!main_queue.isEmpty() && !type.equals("Merge")){
						 test=(Activity)main_queue.remove();
						 type= test.getType();
					 }
				 }else{
				 // skip activities up to merge and then print activities up to merge  
				 //System.out.print(test.getType()+"-"+" : "+test.getPreCondition()); // print decision node
					 //System.out.print(test.getName()+"-"); // print decision node
					 resultPath+=test.getName()+"-";
				 // Skip activities in false part
				 while(!main_queue.isEmpty() && !type.equals("Merge")){
					 test=(Activity)main_queue.remove();
					 type= test.getType();
				 }
				 //System.out.println(test.getType());
				 type="abc";
				 // print activities up-to Merger
				 while(!main_queue.isEmpty() && !type.equals("Merge")){
					 //System.out.println(test.getType());
					 test=(Activity)main_queue.remove();
					 type= test.getType();
					// System.out.print(test.getName()+"-");
					 resultPath+=test.getName()+"-";
				 }
			 	}// end else
			 }//end if decision
			 // print fork nodes from each queue 
			 if(type.equals("Fork")){
				 //System.out.print(test.getName()+"-");
				 resultPath+=test.getName()+"-";
				 //System.out.print("Number of Fork Queues : "+fork_queue.length);
				 Random randomGenerator = new Random(); 
				 int current_queue=randomGenerator.nextInt(fork_queue.length);
				 boolean all_qs_over=false;
				 while(!all_qs_over){
					 while(!fork_queue[current_queue].isEmpty()){
					 //print activity from each queue selected randomly.
						 String lastNodeType=type;
						 test=(Activity)fork_queue[current_queue].remove();
						 type= test.getType();
						 //System.out.print(test+" : "+current_queue);
						// System.out.print(test.getName()+"-");
						 resultPath+=test.getName()+"-";
						 // if next node is of type send signal then switch the queue
						 Activity a = (Activity)fork_queue[current_queue].peek();
						 if(a!=null && a.getType().equals("Send Signal")){
							// System.out.print("Switch-");
							 resultPath+="Switch-";
							 break;
						 }
						 //if last node is of type receive signal then switch the queue
						if(lastNodeType.equals("Receive Signal")){
							// System.out.print("Switch-");
							 resultPath+="Switch-";
							 break;
						}
						// if next node is Unlock
						 if(a!=null && a.getType().equals("Unlock")){
							 //System.out.print("Switch-");
							 resultPath+="Switch-";
							 break;
						 }

					 }
					 all_qs_over=true;
					 // check if all queues are empty
					 for(int j=0; j<fork_queue.length;j++){
						 if(!fork_queue[j].isEmpty())
							 all_qs_over=false;
					 }
					 //select randomly any queue other than current queue
					 int lastCurrent_queue=current_queue;
					 //System.out.println("Last Current queue : "+lastCurrent_queue);
					 while(lastCurrent_queue==current_queue){
						 current_queue=randomGenerator.nextInt(fork_queue.length);
						 //System.out.println("Current queue : "+current_queue);
					 }
				 }
			 }
			 //print Join Node
			 if(type.equals("Join")){
				 //System.out.print(test.getName()+"-");
				 resultPath+=test.getName()+"-";
			 }

			 if(type.equals("End")){
				// System.out.print(test.getName()+"-");
				 resultPath+=test.getName();
			 }
			 

		 }// while main_queue not empty

		//System.out.println(resultPath);
		return resultPath;
	}
	public static void main(String[] args){
		ActivityGraph graph= new ActivityGraph();
		CQSPathGenerator cqs = new CQSPathGenerator(graph);
		//bfs.loadActivityGraph("src\\bank.txt");
		//bfs.loadActivityGraph("src\\bankSequence1.txt");
		//bfs.loadActivityGraph("src\\desktopStartup.txt");
		//bfs.loadActivityGraph("src\\mapRendering.txt");
		//bfs.loadActivityGraph("src\\DiningPhilosopher.txt");
		cqs.loadActivityGraph("src\\TicketReservation1.txt");
		//bfs.loadActivityGraph("src\\activity1.txt");
		//bfs.loadActivityGraph("src\\activity2.txt");
		//bfs.loadActivityGraph("src\\activity3.txt");
		//bfs.loadActivityGraph("src\\activity8.txt");
		//bfs.loadActivityGraph("src\\activity9.txt");
		//bfs.loadActivityGraph("src\\SDD.txt");
		//bfs.loadActivityGraph("src\\SDI.txt");
		//bfs.loadActivityGraph("src\\NDD.txt");
		//bfs.loadActivityGraph("src\\NDI.txt");
		//bfs.loadActivityGraph("src\\SDD.txt");
		//int maxPaths=graph.getpathcount();
		int maxPaths=10;
		System.out.println("Total distinct paths: "+maxPaths);
		//System.out.println(graph);
		//String path=bfs.getPath();
		//System.out.println("\nBFS Path: "+path);
		String []Paths=cqs.getPathSet(maxPaths);
		System.out.println("\nCQS Path set: ");
		for(int i=0; i<maxPaths;i++){
			System.out.println(Paths[i]);
		}
		ArrayList<String> UniquePaths=cqs.getDistinctPathSet(Paths);
		System.out.println("\nCQS Unique Path set: "+UniquePaths.size());
		for(int i=0; i<UniquePaths.size();i++){
			System.out.println(UniquePaths.get(i));
		}

	}
}
